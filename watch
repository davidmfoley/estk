#! /usr/bin/env node
/* eslint-disable no-console */
'use strict';

const path = require('path');
const child_process = require('child_process');
// const fs = require('fs');
const watchr = require('watchr');

let currentTask;
let queue = [];

watch('packages/estk', 'test', './test', 'npm', ['run', '-s', 'test:mocha']);
watch('packages/estk', 'test', './src', 'npm', ['run', '-s', 'test:mocha']);
watch('packages/estk', 'build', './src', 'npm', ['run', '-s', 'build',  'test']);

function watch(cwd, name, relativePath, cmd, args) {
  const fullPath = path.normalize(path.join(__dirname, cwd, relativePath));
  watchr.open(
    fullPath,
    () => {
      if (!taskIsQueued(name)) {
        enqueue(cwd, name, relativePath, cmd, args);
      }
    },
    (err) => {
      if (err) return console.error('Error:', err);
      console.log(`Watching ${fullPath} - ${name}`);
    }
  );
}

function taskIsQueued(name) {
  return !! queue.filter(t => t.name === name).length;
}

function enqueue(cwd, name, path, cmd, args) {
  queue.push({cwd, name, path, cmd, args});
  spawnNext();
}

function spawnNext() {
  if (!queue.length) return;
  if (currentTask) return;

  currentTask = queue.shift();
  const { cwd, name, cmd, args } = currentTask;

  console.log('** ' + name);
  spawn(cwd, cmd, args);
}

function spawn(cwd, cmd, args) {
  const opts = {
    cwd,
    env: process.env,
    stdio: 'inherit'
  };

  console.log('> ' + cmd + ' ' +  args.join(' '));
  return child_process.spawn(cmd, args, opts).on('close', (code) => {
    if (code === 0 ) {
      console.log('SUCCESS');
    }
    else {
      console.log('FAILURE ', code);
    }

    currentTask = undefined;
    spawnNext();
  });
}

